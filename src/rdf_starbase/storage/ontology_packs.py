"""
Ontology Packs for RDF-StarBase.

Provides pre-built templates for common ontologies:
- PROV-O: Provenance ontology
- DCAT: Data Catalog vocabulary  
- PAV: Provenance, Authoring, Versioning

Enable/disable per repository for guided data modeling.
"""

from __future__ import annotations

from dataclasses import dataclass, field
from enum import Enum
from typing import TYPE_CHECKING, Any

if TYPE_CHECKING:
    from .duckdb import RDFStarStore

# Namespace definitions
PROV = "http://www.w3.org/ns/prov#"
DCAT = "http://www.w3.org/ns/dcat#"
PAV = "http://purl.org/pav/"
DCT = "http://purl.org/dc/terms/"
FOAF = "http://xmlns.com/foaf/0.1/"
XSD = "http://www.w3.org/2001/XMLSchema#"
RDF = "http://www.w3.org/1999/02/22-rdf-syntax-ns#"
RDFS = "http://www.w3.org/2000/01/rdf-schema#"


class OntologyPackType(Enum):
    """Types of ontology packs."""
    
    PROV_O = "prov-o"
    DCAT = "dcat"
    PAV = "pav"


@dataclass
class PropertyTemplate:
    """Template for an ontology property."""
    
    uri: str
    label: str
    description: str
    range_type: str  # URI of expected type or "literal"
    domain_type: str | None = None  # URI of expected domain
    required: bool = False
    datatype: str | None = None  # For literal values
    example: str | None = None


@dataclass
class ClassTemplate:
    """Template for an ontology class."""
    
    uri: str
    label: str
    description: str
    properties: list[PropertyTemplate] = field(default_factory=list)
    parent_class: str | None = None
    example_uri: str | None = None


@dataclass
class OntologyPack:
    """A collection of class and property templates."""
    
    pack_type: OntologyPackType
    name: str
    description: str
    namespace: str
    prefix: str
    classes: list[ClassTemplate] = field(default_factory=list)
    properties: list[PropertyTemplate] = field(default_factory=list)
    
    def get_prefixes(self) -> dict[str, str]:
        """Get prefix declarations for this pack."""
        return {self.prefix: self.namespace}
    
    def get_class(self, local_name: str) -> ClassTemplate | None:
        """Get a class template by local name."""
        full_uri = f"{self.namespace}{local_name}"
        for cls in self.classes:
            if cls.uri == full_uri:
                return cls
        return None
    
    def get_property(self, local_name: str) -> PropertyTemplate | None:
        """Get a property template by local name."""
        full_uri = f"{self.namespace}{local_name}"
        for prop in self.properties:
            if prop.uri == full_uri:
                return prop
        return None


def create_prov_o_pack() -> OntologyPack:
    """Create the PROV-O ontology pack."""
    pack = OntologyPack(
        pack_type=OntologyPackType.PROV_O,
        name="PROV-O",
        description="W3C Provenance Ontology for describing provenance of things",
        namespace=PROV,
        prefix="prov",
    )
    
    # Core classes
    pack.classes = [
        ClassTemplate(
            uri=f"{PROV}Entity",
            label="Entity",
            description="A physical, digital, conceptual, or other kind of thing with some fixed aspects",
            properties=[
                PropertyTemplate(
                    uri=f"{PROV}wasGeneratedBy",
                    label="was generated by",
                    description="The activity that generated this entity",
                    range_type=f"{PROV}Activity",
                ),
                PropertyTemplate(
                    uri=f"{PROV}wasDerivedFrom",
                    label="was derived from",
                    description="Another entity from which this entity was derived",
                    range_type=f"{PROV}Entity",
                ),
                PropertyTemplate(
                    uri=f"{PROV}wasAttributedTo",
                    label="was attributed to",
                    description="The agent to whom this entity is attributed",
                    range_type=f"{PROV}Agent",
                ),
                PropertyTemplate(
                    uri=f"{PROV}generatedAtTime",
                    label="generated at time",
                    description="The time at which this entity was created",
                    range_type="literal",
                    datatype=f"{XSD}dateTime",
                ),
            ],
            example_uri="ex:document1",
        ),
        ClassTemplate(
            uri=f"{PROV}Activity",
            label="Activity",
            description="Something that occurs over a period of time and acts upon or with entities",
            properties=[
                PropertyTemplate(
                    uri=f"{PROV}used",
                    label="used",
                    description="An entity used by this activity",
                    range_type=f"{PROV}Entity",
                ),
                PropertyTemplate(
                    uri=f"{PROV}wasAssociatedWith",
                    label="was associated with",
                    description="An agent associated with this activity",
                    range_type=f"{PROV}Agent",
                ),
                PropertyTemplate(
                    uri=f"{PROV}startedAtTime",
                    label="started at time",
                    description="The time at which this activity started",
                    range_type="literal",
                    datatype=f"{XSD}dateTime",
                ),
                PropertyTemplate(
                    uri=f"{PROV}endedAtTime",
                    label="ended at time",
                    description="The time at which this activity ended",
                    range_type="literal",
                    datatype=f"{XSD}dateTime",
                ),
                PropertyTemplate(
                    uri=f"{PROV}wasInformedBy",
                    label="was informed by",
                    description="Another activity that informed this one",
                    range_type=f"{PROV}Activity",
                ),
            ],
            example_uri="ex:dataProcessing",
        ),
        ClassTemplate(
            uri=f"{PROV}Agent",
            label="Agent",
            description="Something that bears some form of responsibility for an activity or entity",
            properties=[
                PropertyTemplate(
                    uri=f"{PROV}actedOnBehalfOf",
                    label="acted on behalf of",
                    description="Another agent this agent acted on behalf of",
                    range_type=f"{PROV}Agent",
                ),
            ],
            example_uri="ex:alice",
        ),
        ClassTemplate(
            uri=f"{PROV}Person",
            label="Person",
            description="A person agent",
            parent_class=f"{PROV}Agent",
            example_uri="ex:bob",
        ),
        ClassTemplate(
            uri=f"{PROV}Organization",
            label="Organization",
            description="An organization agent",
            parent_class=f"{PROV}Agent",
            example_uri="ex:acmeCorp",
        ),
        ClassTemplate(
            uri=f"{PROV}SoftwareAgent",
            label="Software Agent",
            description="A software agent",
            parent_class=f"{PROV}Agent",
            example_uri="ex:dataProcessor",
        ),
    ]
    
    return pack


def create_dcat_pack() -> OntologyPack:
    """Create the DCAT ontology pack."""
    pack = OntologyPack(
        pack_type=OntologyPackType.DCAT,
        name="DCAT",
        description="Data Catalog Vocabulary for describing datasets and data services",
        namespace=DCAT,
        prefix="dcat",
    )
    
    pack.classes = [
        ClassTemplate(
            uri=f"{DCAT}Catalog",
            label="Catalog",
            description="A curated collection of datasets and/or data services",
            properties=[
                PropertyTemplate(
                    uri=f"{DCT}title",
                    label="title",
                    description="Name of the catalog",
                    range_type="literal",
                    datatype=f"{XSD}string",
                    required=True,
                ),
                PropertyTemplate(
                    uri=f"{DCT}description",
                    label="description",
                    description="Free-text description of the catalog",
                    range_type="literal",
                    datatype=f"{XSD}string",
                ),
                PropertyTemplate(
                    uri=f"{DCT}publisher",
                    label="publisher",
                    description="Entity responsible for making the catalog available",
                    range_type=f"{FOAF}Agent",
                ),
                PropertyTemplate(
                    uri=f"{DCAT}dataset",
                    label="dataset",
                    description="A dataset in this catalog",
                    range_type=f"{DCAT}Dataset",
                ),
                PropertyTemplate(
                    uri=f"{DCAT}service",
                    label="service",
                    description="A data service in this catalog",
                    range_type=f"{DCAT}DataService",
                ),
            ],
            example_uri="ex:mainCatalog",
        ),
        ClassTemplate(
            uri=f"{DCAT}Dataset",
            label="Dataset",
            description="A collection of data, published or curated by a single agent",
            properties=[
                PropertyTemplate(
                    uri=f"{DCT}title",
                    label="title",
                    description="Name of the dataset",
                    range_type="literal",
                    datatype=f"{XSD}string",
                    required=True,
                ),
                PropertyTemplate(
                    uri=f"{DCT}description",
                    label="description",
                    description="Free-text description of the dataset",
                    range_type="literal",
                    datatype=f"{XSD}string",
                ),
                PropertyTemplate(
                    uri=f"{DCT}issued",
                    label="issued",
                    description="Date of formal issuance",
                    range_type="literal",
                    datatype=f"{XSD}date",
                ),
                PropertyTemplate(
                    uri=f"{DCT}modified",
                    label="modified",
                    description="Date of last modification",
                    range_type="literal",
                    datatype=f"{XSD}date",
                ),
                PropertyTemplate(
                    uri=f"{DCT}publisher",
                    label="publisher",
                    description="Entity responsible for making the dataset available",
                    range_type=f"{FOAF}Agent",
                ),
                PropertyTemplate(
                    uri=f"{DCAT}distribution",
                    label="distribution",
                    description="Available distribution of the dataset",
                    range_type=f"{DCAT}Distribution",
                ),
                PropertyTemplate(
                    uri=f"{DCAT}keyword",
                    label="keyword",
                    description="Keywords describing the dataset",
                    range_type="literal",
                    datatype=f"{XSD}string",
                ),
                PropertyTemplate(
                    uri=f"{DCAT}theme",
                    label="theme",
                    description="Category/theme of the dataset",
                    range_type=f"{RDFS}Resource",
                ),
            ],
            example_uri="ex:salesData2024",
        ),
        ClassTemplate(
            uri=f"{DCAT}Distribution",
            label="Distribution",
            description="A specific available form of a dataset",
            properties=[
                PropertyTemplate(
                    uri=f"{DCAT}accessURL",
                    label="access URL",
                    description="URL giving access to the distribution",
                    range_type=f"{RDFS}Resource",
                ),
                PropertyTemplate(
                    uri=f"{DCAT}downloadURL",
                    label="download URL",
                    description="URL for direct download",
                    range_type=f"{RDFS}Resource",
                ),
                PropertyTemplate(
                    uri=f"{DCT}format",
                    label="format",
                    description="File format of the distribution",
                    range_type=f"{DCT}MediaType",
                ),
                PropertyTemplate(
                    uri=f"{DCAT}byteSize",
                    label="byte size",
                    description="Size in bytes",
                    range_type="literal",
                    datatype=f"{XSD}nonNegativeInteger",
                ),
                PropertyTemplate(
                    uri=f"{DCAT}mediaType",
                    label="media type",
                    description="IANA media type",
                    range_type=f"{DCT}MediaType",
                ),
            ],
            example_uri="ex:salesDataCSV",
        ),
        ClassTemplate(
            uri=f"{DCAT}DataService",
            label="Data Service",
            description="A data service for accessing datasets",
            properties=[
                PropertyTemplate(
                    uri=f"{DCT}title",
                    label="title",
                    description="Name of the service",
                    range_type="literal",
                    datatype=f"{XSD}string",
                    required=True,
                ),
                PropertyTemplate(
                    uri=f"{DCAT}endpointURL",
                    label="endpoint URL",
                    description="Root location of the service",
                    range_type=f"{RDFS}Resource",
                ),
                PropertyTemplate(
                    uri=f"{DCAT}servesDataset",
                    label="serves dataset",
                    description="Dataset served by this service",
                    range_type=f"{DCAT}Dataset",
                ),
            ],
            example_uri="ex:sparqlEndpoint",
        ),
    ]
    
    return pack


def create_pav_pack() -> OntologyPack:
    """Create the PAV ontology pack."""
    pack = OntologyPack(
        pack_type=OntologyPackType.PAV,
        name="PAV",
        description="Provenance, Authoring and Versioning ontology",
        namespace=PAV,
        prefix="pav",
    )
    
    # PAV focuses on properties rather than new classes
    pack.properties = [
        # Authoring
        PropertyTemplate(
            uri=f"{PAV}authoredBy",
            label="authored by",
            description="Agent(s) who authored the resource",
            range_type=f"{PROV}Agent",
            example="ex:doc pav:authoredBy ex:alice",
        ),
        PropertyTemplate(
            uri=f"{PAV}authoredOn",
            label="authored on",
            description="Date/time when the resource was authored",
            range_type="literal",
            datatype=f"{XSD}dateTime",
        ),
        PropertyTemplate(
            uri=f"{PAV}createdBy",
            label="created by",
            description="Agent who created the digital artifact",
            range_type=f"{PROV}Agent",
        ),
        PropertyTemplate(
            uri=f"{PAV}createdOn",
            label="created on",
            description="Date/time of digital creation",
            range_type="literal",
            datatype=f"{XSD}dateTime",
        ),
        PropertyTemplate(
            uri=f"{PAV}contributedBy",
            label="contributed by",
            description="Agent who contributed to the resource",
            range_type=f"{PROV}Agent",
        ),
        PropertyTemplate(
            uri=f"{PAV}curatedBy",
            label="curated by",
            description="Agent who curated the resource",
            range_type=f"{PROV}Agent",
        ),
        PropertyTemplate(
            uri=f"{PAV}curatedOn",
            label="curated on",
            description="Date/time of curation",
            range_type="literal",
            datatype=f"{XSD}dateTime",
        ),
        
        # Provenance
        PropertyTemplate(
            uri=f"{PAV}derivedFrom",
            label="derived from",
            description="Resource from which this was derived",
            range_type=f"{RDFS}Resource",
        ),
        PropertyTemplate(
            uri=f"{PAV}importedFrom",
            label="imported from",
            description="Source from which the resource was imported",
            range_type=f"{RDFS}Resource",
        ),
        PropertyTemplate(
            uri=f"{PAV}importedBy",
            label="imported by",
            description="Agent who imported the resource",
            range_type=f"{PROV}Agent",
        ),
        PropertyTemplate(
            uri=f"{PAV}importedOn",
            label="imported on",
            description="Date/time of import",
            range_type="literal",
            datatype=f"{XSD}dateTime",
        ),
        PropertyTemplate(
            uri=f"{PAV}retrievedFrom",
            label="retrieved from",
            description="Source from which the resource was retrieved",
            range_type=f"{RDFS}Resource",
        ),
        PropertyTemplate(
            uri=f"{PAV}retrievedBy",
            label="retrieved by",
            description="Agent who retrieved the resource",
            range_type=f"{PROV}Agent",
        ),
        PropertyTemplate(
            uri=f"{PAV}retrievedOn",
            label="retrieved on",
            description="Date/time of retrieval",
            range_type="literal",
            datatype=f"{XSD}dateTime",
        ),
        PropertyTemplate(
            uri=f"{PAV}sourceAccessedAt",
            label="source accessed at",
            description="URI of source that was accessed",
            range_type=f"{RDFS}Resource",
        ),
        PropertyTemplate(
            uri=f"{PAV}sourceAccessedBy",
            label="source accessed by",
            description="Agent who accessed the source",
            range_type=f"{PROV}Agent",
        ),
        PropertyTemplate(
            uri=f"{PAV}sourceAccessedOn",
            label="source accessed on",
            description="Date/time when source was accessed",
            range_type="literal",
            datatype=f"{XSD}dateTime",
        ),
        
        # Versioning
        PropertyTemplate(
            uri=f"{PAV}version",
            label="version",
            description="Version identifier string",
            range_type="literal",
            datatype=f"{XSD}string",
        ),
        PropertyTemplate(
            uri=f"{PAV}previousVersion",
            label="previous version",
            description="URI of the previous version",
            range_type=f"{RDFS}Resource",
        ),
        PropertyTemplate(
            uri=f"{PAV}hasCurrentVersion",
            label="has current version",
            description="URI of the current version",
            range_type=f"{RDFS}Resource",
        ),
        PropertyTemplate(
            uri=f"{PAV}hasVersion",
            label="has version",
            description="URI of a version",
            range_type=f"{RDFS}Resource",
        ),
        PropertyTemplate(
            uri=f"{PAV}lastUpdateOn",
            label="last update on",
            description="Date/time of last update",
            range_type="literal",
            datatype=f"{XSD}dateTime",
        ),
    ]
    
    return pack


class OntologyPackManager:
    """Manages ontology packs for a repository."""
    
    # Available packs (singletons)
    _packs: dict[OntologyPackType, OntologyPack] = {}
    
    def __init__(self) -> None:
        """Initialize pack manager."""
        self.enabled_packs: set[OntologyPackType] = set()
        self._ensure_packs_created()
    
    @classmethod
    def _ensure_packs_created(cls) -> None:
        """Ensure all packs are created."""
        if not cls._packs:
            cls._packs[OntologyPackType.PROV_O] = create_prov_o_pack()
            cls._packs[OntologyPackType.DCAT] = create_dcat_pack()
            cls._packs[OntologyPackType.PAV] = create_pav_pack()
    
    def enable_pack(self, pack_type: OntologyPackType) -> None:
        """Enable an ontology pack."""
        self.enabled_packs.add(pack_type)
    
    def disable_pack(self, pack_type: OntologyPackType) -> None:
        """Disable an ontology pack."""
        self.enabled_packs.discard(pack_type)
    
    def is_enabled(self, pack_type: OntologyPackType) -> bool:
        """Check if a pack is enabled."""
        return pack_type in self.enabled_packs
    
    def get_pack(self, pack_type: OntologyPackType) -> OntologyPack | None:
        """Get a pack by type."""
        return self._packs.get(pack_type)
    
    def get_enabled_packs(self) -> list[OntologyPack]:
        """Get all enabled packs."""
        return [self._packs[pt] for pt in self.enabled_packs if pt in self._packs]
    
    def get_all_packs(self) -> list[OntologyPack]:
        """Get all available packs."""
        return list(self._packs.values())
    
    def get_all_prefixes(self) -> dict[str, str]:
        """Get all prefix declarations from enabled packs."""
        prefixes: dict[str, str] = {}
        for pack in self.get_enabled_packs():
            prefixes.update(pack.get_prefixes())
        return prefixes
    
    def suggest_classes(self, partial: str = "") -> list[ClassTemplate]:
        """
        Suggest classes from enabled packs matching partial input.
        
        Args:
            partial: Partial class name to match
            
        Returns:
            List of matching class templates
        """
        suggestions: list[ClassTemplate] = []
        partial_lower = partial.lower()
        
        for pack in self.get_enabled_packs():
            for cls in pack.classes:
                if partial_lower in cls.label.lower() or partial_lower in cls.uri.lower():
                    suggestions.append(cls)
        
        return suggestions
    
    def suggest_properties(
        self,
        domain_class: str | None = None,
        partial: str = "",
    ) -> list[PropertyTemplate]:
        """
        Suggest properties from enabled packs.
        
        Args:
            domain_class: Filter by domain class URI
            partial: Partial property name to match
            
        Returns:
            List of matching property templates
        """
        suggestions: list[PropertyTemplate] = []
        partial_lower = partial.lower()
        
        for pack in self.get_enabled_packs():
            # Check class-level properties
            for cls in pack.classes:
                if domain_class and cls.uri != domain_class:
                    continue
                
                for prop in cls.properties:
                    if partial_lower in prop.label.lower() or partial_lower in prop.uri.lower():
                        suggestions.append(prop)
            
            # Check pack-level properties
            for prop in pack.properties:
                if domain_class and prop.domain_type and prop.domain_type != domain_class:
                    continue
                
                if partial_lower in prop.label.lower() or partial_lower in prop.uri.lower():
                    suggestions.append(prop)
        
        return suggestions
    
    def suggest_range_values(
        self, property_uri: str
    ) -> dict[str, Any]:
        """
        Suggest appropriate values for a property based on its range.
        
        Args:
            property_uri: URI of the property
            
        Returns:
            Dictionary with range info and suggestions
        """
        for pack in self.get_enabled_packs():
            # Search in class properties
            for cls in pack.classes:
                for prop in cls.properties:
                    if prop.uri == property_uri:
                        return self._build_range_suggestions(prop)
            
            # Search in pack properties
            for prop in pack.properties:
                if prop.uri == property_uri:
                    return self._build_range_suggestions(prop)
        
        return {"type": "unknown", "suggestions": []}
    
    def _build_range_suggestions(self, prop: PropertyTemplate) -> dict[str, Any]:
        """Build range suggestions for a property."""
        result: dict[str, Any] = {
            "property": prop.uri,
            "label": prop.label,
            "description": prop.description,
        }
        
        if prop.range_type == "literal":
            result["type"] = "literal"
            result["datatype"] = prop.datatype
            if prop.datatype == f"{XSD}dateTime":
                result["format"] = "YYYY-MM-DDTHH:MM:SSZ"
                result["example"] = "2024-01-15T10:30:00Z"
            elif prop.datatype == f"{XSD}date":
                result["format"] = "YYYY-MM-DD"
                result["example"] = "2024-01-15"
            elif prop.datatype == f"{XSD}string":
                result["example"] = "Example text"
            elif prop.datatype == f"{XSD}nonNegativeInteger":
                result["example"] = "42"
        else:
            result["type"] = "resource"
            result["rangeClass"] = prop.range_type
            
            # Suggest classes that match the range
            matching_classes = []
            for pack in self.get_enabled_packs():
                for cls in pack.classes:
                    if cls.uri == prop.range_type or cls.parent_class == prop.range_type:
                        matching_classes.append({
                            "uri": cls.uri,
                            "label": cls.label,
                            "example": cls.example_uri,
                        })
            
            result["matchingClasses"] = matching_classes
        
        if prop.example:
            result["example"] = prop.example
        
        return result
    
    def generate_template(
        self,
        class_uri: str,
        subject_uri: str,
        include_optional: bool = True,
    ) -> str:
        """
        Generate a Turtle template for creating an instance.
        
        Args:
            class_uri: URI of the class to instantiate
            subject_uri: URI for the new instance
            include_optional: Include optional properties
            
        Returns:
            Turtle template string
        """
        # Find the class
        class_template = None
        pack_found = None
        
        for pack in self.get_enabled_packs():
            for cls in pack.classes:
                if cls.uri == class_uri:
                    class_template = cls
                    pack_found = pack
                    break
            if class_template:
                break
        
        if not class_template or not pack_found:
            return f"# Class {class_uri} not found in enabled packs"
        
        # Build template
        lines = [
            f"@prefix {pack_found.prefix}: <{pack_found.namespace}> .",
            "@prefix rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#> .",
            "@prefix xsd: <http://www.w3.org/2001/XMLSchema#> .",
            "",
            f"<{subject_uri}> a {pack_found.prefix}:{class_uri.split('#')[-1].split('/')[-1]} ;",
        ]
        
        # Add properties
        property_lines = []
        for prop in class_template.properties:
            if not include_optional and not prop.required:
                continue
            
            # Generate placeholder value
            prefix_local = prop.uri.replace(pack_found.namespace, f"{pack_found.prefix}:")
            if not prefix_local.startswith(f"{pack_found.prefix}:"):
                # Check other common prefixes
                if prop.uri.startswith(DCT):
                    prefix_local = prop.uri.replace(DCT, "dct:")
                elif prop.uri.startswith(FOAF):
                    prefix_local = prop.uri.replace(FOAF, "foaf:")
                else:
                    prefix_local = f"<{prop.uri}>"
            
            if prop.range_type == "literal":
                if prop.datatype == f"{XSD}dateTime":
                    value = '"YYYY-MM-DDTHH:MM:SSZ"^^xsd:dateTime'
                elif prop.datatype == f"{XSD}date":
                    value = '"YYYY-MM-DD"^^xsd:date'
                elif prop.datatype == f"{XSD}nonNegativeInteger":
                    value = '"0"^^xsd:nonNegativeInteger'
                else:
                    value = '"..."'
            else:
                value = "<...>"
            
            comment = f"  # {prop.description}" if prop.description else ""
            required_marker = " # REQUIRED" if prop.required else ""
            property_lines.append(f"    {prefix_local} {value}{required_marker}{comment}")
        
        # Join with semicolons
        if property_lines:
            lines.extend([line + " ;" for line in property_lines[:-1]])
            lines.append(property_lines[-1] + " .")
        else:
            lines[-1] = lines[-1].rstrip(" ;") + " ."
        
        return "\n".join(lines)
    
    def to_dict(self) -> dict[str, Any]:
        """Serialize pack manager state to dictionary."""
        return {
            "enabledPacks": [pt.value for pt in self.enabled_packs],
        }
    
    @classmethod
    def from_dict(cls, data: dict[str, Any]) -> "OntologyPackManager":
        """Deserialize pack manager from dictionary."""
        manager = cls()
        for pack_value in data.get("enabledPacks", []):
            try:
                pack_type = OntologyPackType(pack_value)
                manager.enable_pack(pack_type)
            except ValueError:
                pass
        return manager
    
    def get_summary(self) -> dict[str, Any]:
        """Get summary of all packs and their status."""
        return {
            "packs": [
                {
                    "type": pack.pack_type.value,
                    "name": pack.name,
                    "description": pack.description,
                    "namespace": pack.namespace,
                    "prefix": pack.prefix,
                    "enabled": pack.pack_type in self.enabled_packs,
                    "classCount": len(pack.classes),
                    "propertyCount": len(pack.properties) + sum(
                        len(cls.properties) for cls in pack.classes
                    ),
                }
                for pack in self.get_all_packs()
            ],
            "enabledCount": len(self.enabled_packs),
        }


class SchemaGuidance:
    """
    Provides schema guidance during data authoring.
    
    Combines SHACL validation with ontology pack suggestions
    to help users create valid, well-structured RDF data.
    """
    
    def __init__(
        self,
        pack_manager: OntologyPackManager,
        shacl_manager: Any | None = None,  # SHACLManager
    ) -> None:
        """Initialize schema guidance."""
        self.pack_manager = pack_manager
        self.shacl_manager = shacl_manager
    
    def get_autocomplete(
        self,
        context: str,
        cursor_position: int,
    ) -> list[dict[str, Any]]:
        """
        Get autocomplete suggestions based on context.
        
        Args:
            context: Current text/query context
            cursor_position: Position in the context
            
        Returns:
            List of completion suggestions
        """
        suggestions: list[dict[str, Any]] = []
        
        # Extract the word being typed
        before_cursor = context[:cursor_position]
        
        # Check if we're typing a prefix
        if ":" in before_cursor:
            prefix_part = before_cursor.split()[-1] if before_cursor.split() else ""
            if ":" in prefix_part:
                prefix, local = prefix_part.rsplit(":", 1)
                
                # Find matching pack
                for pack in self.pack_manager.get_enabled_packs():
                    if pack.prefix == prefix:
                        # Suggest classes and properties
                        for cls in pack.classes:
                            local_name = cls.uri.replace(pack.namespace, "")
                            if local.lower() in local_name.lower():
                                suggestions.append({
                                    "label": f"{prefix}:{local_name}",
                                    "kind": "class",
                                    "detail": cls.description,
                                    "insertText": local_name,
                                })
                        
                        for prop in pack.properties:
                            local_name = prop.uri.replace(pack.namespace, "")
                            if local.lower() in local_name.lower():
                                suggestions.append({
                                    "label": f"{prefix}:{local_name}",
                                    "kind": "property",
                                    "detail": prop.description,
                                    "insertText": local_name,
                                })
        
        # Check if we're after 'a ' (type declaration)
        if before_cursor.rstrip().endswith(" a"):
            for cls_template in self.pack_manager.suggest_classes():
                pack = self._find_pack_for_class(cls_template.uri)
                if pack:
                    local_name = cls_template.uri.replace(pack.namespace, "")
                    suggestions.append({
                        "label": f"{pack.prefix}:{local_name}",
                        "kind": "class",
                        "detail": cls_template.description,
                        "insertText": f"{pack.prefix}:{local_name}",
                    })
        
        return suggestions
    
    def _find_pack_for_class(self, class_uri: str) -> OntologyPack | None:
        """Find the pack containing a class."""
        for pack in self.pack_manager.get_enabled_packs():
            for cls in pack.classes:
                if cls.uri == class_uri:
                    return pack
        return None
    
    def validate_and_suggest(
        self,
        triples: list[tuple[str, str, str]],
    ) -> dict[str, Any]:
        """
        Validate triples and suggest improvements.
        
        Args:
            triples: List of (subject, predicate, object) tuples
            
        Returns:
            Validation results and suggestions
        """
        result: dict[str, Any] = {
            "valid": True,
            "errors": [],
            "warnings": [],
            "suggestions": [],
        }
        
        # Run SHACL validation if available
        if self.shacl_manager and self.shacl_manager.shapes_loaded:
            report = self.shacl_manager.validate_triples(triples)
            result["valid"] = report.conforms
            
            for violation in report.violations():
                result["errors"].append({
                    "focusNode": violation.focus_node,
                    "path": violation.result_path,
                    "message": violation.message,
                })
            
            for warning in report.warnings():
                result["warnings"].append({
                    "focusNode": warning.focus_node,
                    "path": warning.result_path,
                    "message": warning.message,
                })
        
        # Add ontology-based suggestions
        subjects: dict[str, list[tuple[str, str]]] = {}
        for s, p, o in triples:
            subjects.setdefault(s, []).append((p, o))
        
        for subject, predicates in subjects.items():
            # Find types
            types = [o for p, o in predicates if p == f"{RDF}type"]
            
            for type_uri in types:
                # Find matching class template
                for pack in self.pack_manager.get_enabled_packs():
                    for cls in pack.classes:
                        if cls.uri == type_uri:
                            # Check for missing required properties
                            existing_preds = {p for p, _o in predicates}
                            
                            for prop in cls.properties:
                                if prop.required and prop.uri not in existing_preds:
                                    result["suggestions"].append({
                                        "type": "missing_required",
                                        "subject": subject,
                                        "property": prop.uri,
                                        "label": prop.label,
                                        "message": f"Required property '{prop.label}' is missing",
                                    })
                            
                            # Suggest additional relevant properties
                            for prop in cls.properties:
                                if not prop.required and prop.uri not in existing_preds:
                                    result["suggestions"].append({
                                        "type": "suggested_property",
                                        "subject": subject,
                                        "property": prop.uri,
                                        "label": prop.label,
                                        "message": f"Consider adding '{prop.label}'",
                                    })
        
        return result
